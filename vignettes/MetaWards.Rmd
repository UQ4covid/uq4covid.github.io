---
title: "Information on MetaWards"
author: "TJ McKinley"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: html_document
---

This is a short document (not really a vignette) describing some key aspects of MetaWards that are pertinent to this UQ attempt. 

**THIS IS NOT COMPLETED YET, BUT GIVES SOME IDEAS ABOUT HOW THE MODEL IS EVOLVING.**

# Model description

We ideally want a model that incorporates moves to hospital and ICU. Here each class is split into two components, e.g. $E_1$ and $E_2$. This is so that MetaWards can calulate new movements into each class easily. Individuals progress out of the first of these classes after exactly one day with probability 1. This means that the time spent in each $E$, $I$, $A$ or $H$ class is *at least one day*. Here:

* $E$: infected but not infectious;
* $A$: asymptomatic and infectious;
* $I$: symptomatic and infectious;
* $H$: hospitalised and infectious;
* $C$: in critical care (ICU) and infectious;
* $R$: recovered and immune;
* $D$: died.

```{r, echo = FALSE}
library(DiagrammeR)
grViz("digraph {
  
graph[layout = dot, rankdir = LR]

node [shape = rectangle]

S
E1 [label = 'E@_{1}']
E2 [label = 'E@_{2}']
I1 [label = 'I@_{1}']
I2 [label = 'I@_{2}']
A1 [label = 'A@_{1}']
A2 [label = 'A@_{2}']
H1 [label = 'H@_{1}']
H2 [label = 'H@_{2}']
C1 [label = 'C@_{1}']
C2 [label = 'C@_{2}']
D
R

S -> E1 -> E2 -> {A1, I1}
A1 -> A2 -> R
I1 -> I2
I2 -> {H1, D, R}
H1 -> H2 -> {C1, D, R}
C1 -> C2 -> {D, R}

subgraph {
  rank = same; I1; A1;
}
subgraph {
  rank = same; I2; A2;
}

}", height = '100%', width = '100%')
```

## MetaWards setup

The model structure above allows for different progression pathways. MetaWards deals with this by assigning individuals to different "demographics", where each demographic can be used to represent different progression pathways. There are also `mover` functions that can be used to move individuals between demographics, and `mixer` functions that scale the force-of-infection (FOI) terms between the different demographics (explained later). There are currently seven pathways, which will be described below, but can be summarised as:

* `SEAR`: asymptomatic infections, always recover.
* `SEIR`: symptomatic infections, leading to recovery.
* `SEID`: symptomatic infections, leading to death.
* `SEIHR`: symptomatic infections, leading to hospital and then recovery.
* `SEIHD`: symptomatic infections, leading to hospital and then death.
* `SEIHCR`: symptomatic infections, leading to hospital, then critical care (ICU) and then recovery.
* `SEIHCD`: symptomatic infections, leading to hospital, then critical care (ICU) and then death.

In practice, we can summarise these through four demographics, and then `move` functions that conditionally move individuals through the seven pathways. First, we set up the `demographics.json` file, which should look something like:

```
{
  "demographics" : ["genpop", "asymp", "hospital", "critical"],
  "work_ratios"  : [ 1.0, 0.0, 0.0, 0.0 ],
  "play_ratios"  : [ 1.0, 0.0, 0.0, 0.0 ],
  "diseases"     : [ null, null, null, null ]
}
```

Individuals in the `genpop` demographic move through the $SEIR$ and $SEID$ pathways; the `asymp` demographic moves through the `SEAR` pathway; some individuals in the `genpop` demographic can be moved to the `hospital` demographic, and thus follow the `SEIHR` and `SEIHD` pathways; and finally, some individuals in the `hospital` demographic can be moved to the `critical` demographic, and thus follow the `SEIHCR` and `SEIHCD` pathways.

We want the proportions stored in `work_ratios` and `play_ratios` to be variable parameters in the model. Therefore we want to specify proportions of individuals in each pathway such that $\sum_{i \in \mathcal{P}} p_i = 1$, where $\mathcal{P} = \{GP, A, H, C\}$.

> Here we assume the same ratios in the `work` and `play` populations, but in practice these could be changed.

### Parameters

Once the demographics have been setup, we can then control progress through the different states as:

* $p_{SE_1}$ driven by $\beta$ parameters, defined by $R_0$ and length of infectious period (see [here](#code));
* $p_{E_1E_2} = 1$;
* $p_{E_2A_1} = p_{EA}\left(1 - e^{-\gamma^*_{E}}\right)$ where $\gamma^*_E = \frac{1}{T_E - 1}$ with $T_E$ the mean incubation period;
* $p_{A_1A_2} = 1$;
* $p_{A_2R} = 1 - e^{-\gamma^*_I}$ where $\gamma^*_I = \frac{1}{T_I - 1}$ with $T_I$ the mean infectious period;
* $p_{E_2I_1} = \left(1 - p_{EA}\right)\left(1 - e^{-\gamma^*_{E}}\right)$;
* $p_{I_1I_2} = 1$;
* $p_{I_2H_1} = p_{IH}\left(1 - e^{-\gamma^*_{I}}\right)$ where $\gamma^*_I = \frac{1}{T_I - 1}$;
* $p_{I_2R} = p_{IR}\left(1 - e^{-\gamma^*_{I}}\right)$;
* $p_{I_2D} = \left(1 - p_{IH} - p_{IR}\right)\left(1 - e^{-\gamma^*_{I}}\right)$;
* $p_{H_1H_2} = 1$;
* $p_{H_2C_1} = p_{HC}\left(1 - e^{-\gamma^*_{HC}}\right)$ where $\gamma^*_{HC} = \frac{1}{T_H - T_C - 1}$ with $T_H$ the mean length of a hospital stay and $T_C$ is the mean length of time spent in ICU;
* $p_{H_2R} = p_{HR}\left(1 - e^{-\gamma^*_{H}}\right)$ where $\gamma^*_H = \frac{1}{T_H - 1}$;
* $p_{H_2D} = \left(1 - p_{HC} - p_{HR}\right)\left(1 - e^{-\gamma^*_{H}}\right)$;
* $p_{C_1C_2} = 1$;
* $p_{C_2R} = p_{CR}\left(1 - e^{-\gamma^*_{C}}\right)$ where $\gamma^*_C = \frac{1}{T_C - 1}$ with $T_C$ is the mean length of time spent in ICU;
* $p_{C_2D} = \left(1 - p_{CR}\right)\left(1 - e^{-\gamma^*_{C}}\right)$.

Lockdown can be controlled either by constraining movements over a certain distance, or by scaling the $\beta$ parameters. We do the latter at the moment.

### Disease `.json` file

All pathways have an $SEI(R)$ structure, so we can set up an `ncov.json` file for the overall disease:

```
{ "name"             : "SARS-Cov-2",
  "version"          : "June 9th 2020",
  "author(s)"        : "UQ4COVID Team",
  "contact(s)"       : "e-mail...",
  "reference(s)"     : "references...",  
  "beta"             : [0.0, 0.0, 1.0, 1.0, 0.0, 0.0],
  "progress"         : [1.0, 1.0, 1.0, 1.0, 0.0, 0.0],
  "too_ill_to_move"  : [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
  "contrib_foi"      : [1.0, 1.0, 1.0, 1.0, 0.0, 0.0]
}
```

> **Note:** We would want asymptomatics to be less infectious than symptomatics, so could amend $\beta$, or set `contrib_foi`?

### Moving functions

We need moving functions to move individuals from $E_2 \to A_1$, $E_2 \to I_1$, $I_2 \to H_1$ and $H_2 \to C_1$, and thus we need a custom `move` function. Create a file `move_pathways.py` containing:

```
from metawards.movers import go_stage

def move_pathways(**kwargs):
    # extract user defined parameters
    params = network.params

    pEA = params.user_params["pEA"]
    pIH = params.user_params["pIH"]
    pIR = params.user_params["pIR"]
    pHC = params.user_params["pHC"]
    pHR = params.user_params["pHR"]
    pCR = params.user_params["pCR"]

    # move (100 * pEA)% of E2 genpop to A1 asymp
    func1 = lambda **kwargs: go_stage(go_from="genpop",
                                      go_to="asymp",
                                      from_stage=1,
                                      to_stage=2,
                                      fraction=pEA,
                                      **kwargs)

    # move A2 asymp to R genpop
    func2 = lambda **kwargs: go_stage(go_from="asymp",
                                      go_to="genpop",
                                      from_stage=3,
                                      to_stage=4,
                                      fraction=1.0,
                                      **kwargs)
                                      
    # move (100 * pIH)% of I2 genpop to H1 hospital
    func3 = lambda **kwargs: go_stage(go_from="genpop",
                                      go_to="hospital",
                                      from_stage=3,
                                      to_stage=2,
                                      fraction=pIH,
                                      **kwargs)
                                      
    # move (100 * (1 - pIH - pIR))% of I2 genpop to D genpop
    # (1 - pIH) adjustment is due to ordering of events (so
    # operates on remainder from move above)
    func4 = lambda **kwargs: go_stage(go_from="genpop",
                                      go_to="genpop",
                                      from_stage=3,
                                      to_stage=5,
                                      fraction=(1.0 - pIH - pIR) / (1.0 - pIH),
                                      **kwargs)
                                      
    # move (100 * pHC)% of H2 hospital to C1 critical
    func5 = lambda **kwargs: go_stage(go_from="hospital",
                                      go_to="critical",
                                      from_stage=3,
                                      to_stage=2,
                                      fraction=pHC,
                                      **kwargs)
                                      
    # move (100 * pHR)% of H2 hospital to R genpop
    # (1 - pHC) adjustment is due to ordering of events (so
    # operates on remainder from move above)
    func6 = lambda **kwargs: go_stage(go_from="hospital",
                                      go_to="genpop",
                                      from_stage=3,
                                      to_stage=4,
                                      fraction=pHR / (1 - pHC),
                                      **kwargs)
                                      
    # move remainder of H2 hospital to D genpop
    func7 = lambda **kwargs: go_stage(go_from="hospital",
                                      go_to="genpop",
                                      from_stage=3,
                                      to_stage=5,
                                      fraction=1.0,
                                      **kwargs)
                                      
    # move (100 * pCR)% of C2 critical to R genpop
    func8 = lambda **kwargs: go_stage(go_from="critical",
                                      go_to="genpop",
                                      from_stage=3,
                                      to_stage=4,
                                      fraction=pCR,
                                      **kwargs)
                                      
    # move remainder of C2 critical to D genpop
    func9 = lambda **kwargs: go_stage(go_from="critical",
                                      go_to="genpop",
                                      from_stage=3,
                                      to_stage=5,
                                      fraction=1.0,
                                      **kwargs)

    return [func1, func2, func3, func4, func5, func6, func7, func8, func9]
```

### Interaction matrices

The **interaction matrix** scales the FOI that different demographics have on other demographics. We need to store this in a file called `mix_pathways.py`:

```
from metawards.mixers import merge_using_matrix

def mix_pathways(network, **kwargs):
    params = network.params

    GP_GP = params.user_params["GP_GP"]
    GP_A = params.user_params["GP_A"]
    GP_H = params.user_params["GP_H"]
    GP_C = params.user_params["GP_C"]

    A_GP = params.user_params["A_GP"]
    A_A = params.user_params["A_A"]
    A_H = params.user_params["A_H"]
    A_C = params.user_params["A_C"]

    H_GP = params.user_params["H_GP"]
    H_A = params.user_params["H_A"]
    H_H = params.user_params["H_H"]
    H_C = params.user_params["H_C"]

    C_GP = params.user_params["C_GP"]
    C_A = params.user_params["C_A"]
    C_H = params.user_params["C_H"]
    C_C = params.user_params["C_C"]

    matrix = [ [GP_GP, GP_A, GP_H, GP_C],
               [A_GP, A_A, A_H, A_C],
               [H_GP, H_A, H_H, H_C],
               [C_GP, C_A, C_H, C_C] ]

    network.demographics.interaction_matrix = matrix

    return [merge_using_matrix]
```

### Code {#code}

To run designs, we need to generate a `disease.csv` file containing different parameters to use for different runs. For consistency, we will define three spaces:

* *input* space: this relates to the parameters ranges (defined below);
* *design* space: this will usually be in $(0, 1)$ or $(-1, 1)$ space;
* *disease* space: this relates to parameters that are fed into MetaWards.

The *input* and *design* spaces are fairly trivial to convert between, but some more work has to be done to convert between the *input* space and the *disease* space.

The current *input* parameter ranges are:
\begin{align}
    \mbox{$R_0$}&: (2.5, 4)\\
    \mbox{mean incubation period ($T_E$)}&: (4, 6)\\
    \mbox{mean infectious period ($T_I$)}&: (2, 4)\\
    \mbox{mean hospital stay ($T_H$)}&: (4, 12)\\
    \mbox{proportion of hospital time spent in critical care ($p_{tC}$)}&: (0, 1)\\
    \mbox{lockdown 1 restrict}&: (0, 1)\\
    \mbox{lockdown 2 release}&: (0, 1)\\
    p_{EA}&: (0, 1)\\
    p_{IH}&: (0, 1)\\
    p_{IR}&: (0, 1) \quad \mbox{such that}~\sum_{i \in \{H, R\}} p_{Ii} < 1\\
    p_{HC}&: (0, 1)\\
    p_{HR}&: (0, 1) \quad \mbox{such that}~\sum_{i \in \{C, R\}} p_{Hi} < 1\\
    p_{CR}&: (0, 1)
\end{align}
We have that the time in critical care, $T_C$, must be a proportion of the time spent in hospital, $T_H$, and thus
$$
    T_C = p_{tC}T_H.
$$

We need: **ranges for the length of hospital stay** (perhaps chat to Rob Challen)? Current hospital rough guides taken from [https://www.medrxiv.org/content/10.1101/2020.04.23.20076042v1.full.pdf](https://www.medrxiv.org/content/10.1101/2020.04.23.20076042v1.full.pdf). (I've stuck in IQR for comparison, but clearly we need to think about this more.)

To ensure orthogonality, we could reparameterise such that:
\begin{align}
    p_{IR} &= \left(1 - p_{IH}\right) p^\prime_{IR}\\
    p_{HR} &= \left(1 - p_{HC}\right) p^\prime_{HR}
\end{align}
and thus we have parameter ranges:
\begin{align}
    \mbox{$R_0$}&: (2.5, 4)\\
    \mbox{mean incubation period ($T_E$)}&: (4, 6)\\
    \mbox{mean infectious period ($T_I$)}&: (2, 4)\\
    \mbox{mean hospital stay ($T_H$)}&: (4, 12)\\
    \mbox{proportion of hospital time spent in critical care ($p_{tC}$)}&: (0, 1)\\
    \mbox{lockdown 1 restrict}&: (0, 1)\\
    \mbox{lockdown 2 release}&: (0, 1)\\
    p_{EA}&: (0, 1)\\
    p_{IH}&: (0, 1)\\
    p^\prime_{IR}&: (0, 1)\\
    p_{HC}&: (0, 1)\\
    p^\prime_{HR}&: (0, 1)\\
    p_{CR}&: (0, 1)
\end{align}
and this has removed the sum-to-one-constraints.

In R we can set up the *input* parameter ranges as follows:

```{r}
## set up parameter ranges
parRanges <- data.frame(
    parameter = c("r_zero", "incubation_time", "infectious_time", "hospital_time",
                  "ptC", "lock_1_restrict", "lock_2_release",
                  "pEA", "pIH", "pIRprime", "pHC", "pHRprime", "pCR"),
    lower = c(2.5, 4, 2, 4, rep(0, 9)),
    upper = c(4, 6, 4, 12, rep(1, 9)),
    stringsAsFactors = FALSE
)
```

Firstly we want a function to convert between the *design* and *input* spaces. A short R function to do this is given below. This requires a `design` data frame, with columns denoting each *input* parameter in `parRanges` and rows corresponding to design points, and a `parRanges` data frame (defined above). We use the `scale` argument to define whether the design is on the $(0, 1)$ (`scale = "zero_one"`) or $(-1, 1)$ (`scale = "negone_one"`) space.

```{r}
## function to convert from design to input space
convertDesignToInput <- function(design, parRanges, scale = c("zero_one", "negone_one")) {
  
    ## ACTUAL CODE WILL HAVE CHECKS ON INPUTS HERE 
    require(dplyr)
    require(tidyr)
  
    ## convert from design space to input space
    input <- mutate(design, ind = 1:n()) %>%
        gather(parameter, value, -ind) %>%
        left_join(parRanges, by = "parameter")
    if(scale[1] == "negone_one") {
        input <- mutate(input, value = value / 2 + 1)
    }
    input <- mutate(input, value = value * (upper - lower) + lower) %>%
        dplyr::select(ind, parameter, value) %>%
        spread(parameter, value) %>%
        arrange(ind) %>%
        dplyr::select(-ind)
    
    ## return inputs
    input
}
```

Once we have done this, we need to transform from the *input* space to the *disease* space for MetaWards. A short R function is given below. This requires an `input` data frame, with columns denoting each *input* parameter and rows corresponding to each input points, and a number of `repeats`.

```{r}
## function to convert from input to disease space
convertInputToDisease <- function(input, repeats) {
  
    ## ACTUAL CODE WILL HAVE CHECKS ON INPUTS HERE 
    require(dplyr)
    
    ## common parameters to all pathways
    disease <- tibble(`beta[2]` = input$r_zero / input$infectious_time)
    disease$`beta[3]` <- disease$`beta[2]`
    disease$`progress[0]` <- 1
    disease$`progress[1]` <- 1 - exp(-(1 / (input$incubation_time - 1)))
    disease$`progress[2]` <- 1
    disease$`progress[3]` <- 1 - exp(-(1 / (input$infectious_time - 1)))
    disease$`.scale_rate[1]` <- input$lock_1_restrict
    disease$`.scale_rate[2]` <- input$lock_2_release
    
    ## hospital progression
    disease$`hospital:progress[2]` <- 1
    disease$`hospital:progress[3]` <- 1 - exp(-(1 / (input$hospital_time - 1)))
    
    ## critical care progression
    disease$`critical:progress[2]` <- 1
    disease$`critical:progress[3]` <- 1 - exp(-(1 / input$ptC * (input$hospital_time - 1)))
    
    ## finalise number of repeats
    disease$repeats <- repeats
    
    ## return disease file
    disease
}
```

> **TODO: add attenuated infection rate for asymptomatics.**

> **QUESTION**: do we want to set $T_H$ to be a subset of $T_I$, or in addition to $T_I$? How do we specify ranges?

> **QUESTION**: how do we scale FOI from hospital patients to the other populations?

We also need to create a file to scan across the different `mixing` from the same *design* matrix used above. The following R function will do this.

```{r}
## function to convert input samples to move files
convertInputToMove <- function(input) {
  
    ## ACTUAL CODE WILL HAVE CHECKS ON INPUTS HERE 
    require(dplyr)
  
    ## set up probabilities on disease scale
    pEA <- input$pEA
    pIH <- input$pIH
    pIR <- (1 - pIH) * input$pIRprime
    pHC <- input$pHC
    pHR <- (1 - pHC) * input$pHRprime
    pCR <- input$pCR
    
    ## set up scanning file
    scan <- tibble(
      `.pEA` = pEA,
      `.pIH` = pIH,
      `.pIR` = pIR,
      `.pHC` = pHC,
      `.pHR` = pHR,
      `.pCR` = pCR)
    
    ## return scan files
    scan
}
```

As an example of a quick LHS design for five design points and five replicates:

```{r}
## load libraries
library(lhs)
library(dplyr)
library(tidyr)

## generate LHS design
design <- randomLHS(5, nrow(parRanges))
colnames(design) <- parRanges$parameter
design <- as_tibble(design)

## convert to input space
input <- convertDesignToInput(design, parRanges, "zero_one")

## convert input to disease
disease <- convertInputToDisease(input, 5)

## convert input to move
move <- convertInputToMove(input)

## write to external files
dir.create("inputs")
write.csv(disease, "inputs/disease.csv", row.names = FALSE)
write.table(move, "inputs/move.dat", row.names = FALSE, sep = " ")
```

> **TODO: might want some form of folder clearup or suchlike?**



