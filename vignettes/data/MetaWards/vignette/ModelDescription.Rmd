---  
title: Model Description
author: "TJ McKinley"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document:
    highlight: zenburn
    css: css/main.css
---

<center>

**Requires MetaWards 1.4.1**

Please download files for running the model from **[here](metawards.zip)**.

</center>

<a name="model"></a>

The basic model structure is:

* $E$: infected but not infectious;
* $A$: asymptomatic and infectious;
* $I$: symptomatic and infectious;
* $H$: hospitalised and not infectious;
* $R$: recovered and immune, or symptomatic and not infectious;
* $D$: died.

**Each of these classes will be split into $J$ age-classes, with interactions between the classes described in detail below.**

```{r, echo = FALSE}
library(DiagrammeR)
grViz("digraph simpmod {
    graph[layout = dot, rankdir = LR]
    node [shape = rectangle]
    
    S [group = gp]; E [group = gp]; I [group = gp];  
    RI [label = 'R@_{I}', group = as]; DI [label = 'D@_{I}', group = gp]; 
    A [group = as]; RA [label = 'R@_{A}', group = as];
    H [group = hos]; RH [label = 'R@_{H}', group = hos]; DH [label = 'D@_{H}', group = hos];
    genpop [label = 'Gen. Pop.', group = gp]
    asymp [label = 'Asymptomatics', group = as]
    hospital [label = 'Hospital Patient', group = hos]
    St00 [style = 'invis', group = st]; St0 [style = 'invis', label = 'Stage 0', group = st]; 
    St1 [style = 'invis', label = 'Stage 1', group = st]; 
    St2 [style = 'invis', label = 'Stage 2', group = st]; 
    
    genpop -> S [style = 'invis']
    hospital -> H [style = 'invis']
    asymp -> A [style = 'invis']
    S -> E 
    E -> I [label = '(1 - p@_{EA})T@_{E}']
    I -> RI [weight = 0, label = 'p@_{IR}T@_{I}']
    I -> DI [weight = 0, label = '(1 - p@_{IH} - p@_{IR})T@_{I}']
    I -> H [label = 'p@_{IH}T@_{I}']
    H -> RH [weight = 0, label = 'p@_{HR}T@_{H}']
    H -> DH [weight = 0, label = '(1 - p@_{HR})T@_{H}'] 
    RI -> DI [style = 'invis']
    RH -> DH [style = 'invis']
    E -> A [label = 'p@_{EA}T@_{E}']
    A -> RA [label = 'T@_{I}']
    St00 -> St0 -> St1 -> St2 [style = 'invis']
    subgraph {
      rank = same; St0; E;
    }
    subgraph {
      rank = same; St00 -> asymp -> genpop -> hospital [style = 'invis']
    }
    subgraph cluster {
      subgraph {
        rank = same; A -> I -> H [style = 'invis']
      }
      style = filled;
      color = lightgrey;
      label = 'Infectious Classes'
    }
    subgraph {
      rank = same; St2; RA; RI; DI; RH; DH;
    }
    
}", height = '100%', width = '100%')
```

## MetaWards setup

The model structure above allows for different progression pathways. MetaWards deals with this by assigning individuals to different "demographics", where each demographic can be used to represent different progression pathways. There are also `mover` functions that can be used to move individuals between demographics, and `mixer` functions that scale the force-of-infection (FOI) terms between the different demographics (explained later). There are currently five pathways, which will be described below, but can be summarised as:

* $SEAR$: asymptomatic infections, always recover.
* $SEIR$: symptomatic infections, leading to recovery.
* $SEID$: symptomatic infections, leading to death.
* $SEIHR$: symptomatic infections, leading to hospital and then recovery.
* $SEIHD$: symptomatic infections, leading to hospital and then death.

Individuals start in the `genpop` demographic. Those that move through the $SEIR$ and $SEID$ pathways remain in the `genpop` demographic, whereas those that progress through the `SEAR` pathway move into the `asymp` demographic. Furthermore, some individuals in the `genpop` demographic can be moved to the `hospital` demographic if they follow the `SEIHR` and `SEIHD` pathways.

We are calibrating to hospitalised deaths, and so to simplify the model and aid calibration, we assume that transitions out of the $I$ class correspond to an end-of-infectiousness. Some evidence suggests that individuals can remain symptomatic for much longer than they remain infectious for, but from a transmission perspective, once individuals cease to be infectious they are equivalent to "recovered" individuals. As such, the $R_I$ class corresponds to recovered and non-infectious symptomatic individuals, and $T_I$ to the average infectious period (not average symptomatic period). We also make the simplifying assumption that individuals cease to be infectious when they enter hospital. Hospital-to-general population transmission is thought to be low <p style="color:red">[REF]</p>, but this will interact with the definition of $T_I$ <p style="color:red">[JUSTIFY]</p>.

We need to specify initial proportions of individuals in each pathway such that $\sum_{i \in \mathcal{P}}\sum_{j = 1}^J p_{ij} = 1$, where $\mathcal{P} = \{GP, A, H\}$ and $j = 1, \dots, J$ define the $J$ mutually exclusive age-classes. Here we define the proportions of individuals in each age class from the data in the `inputs/Pop by CTRY.csv` file from Rob:

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}
library(tidyverse)

## read in age-bands by country
ages <- read_csv("../inputs/Pop\ by\ CTRY.csv") %>%
  filter(!is.na(ageCat)) %>%
  filter(code == "E92000001") %>%
  select(-gender, -code) %>%
  mutate(prop = round(count / sum(count), 3))
stopifnot(sum(ages$prop) == 1)
C <- read.csv("../inputs/contact_matrix.csv", header = FALSE)
stopifnot(all(dim(C) == nrow(ages)))
knitr::kable(ages)
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
## create demographics file
demo <- "{" %>%
  c(paste0("\t\"demographics\" : [", paste0(paste0("\"genpop", 1:nrow(ages), "\""), collapse = ", "), ",")) %>%
  c(paste0("\t\t", paste0(paste0("\"asymp", 1:nrow(ages), "\""), collapse = ", "), ",")) %>%
  c(paste0("\t\t", paste0(paste0("\"hospital", 1:nrow(ages), "\""), collapse = ", "), "],")) %>%
  c(paste0("\t\"work_ratios\" : [", paste0(ages$prop, collapse = ", "), ",")) %>%
  c(paste0("\t\t", paste0(rep("0.0", nrow(ages)), collapse = ", "), ",")) %>%
  c(paste0("\t\t", paste0(rep("0.0", nrow(ages)), collapse = ", "), "],")) %>%
  c(paste0("\t\"play_ratios\" : [", paste0(ages$prop, collapse = ", "), ",")) %>%
  c(paste0("\t\t", paste0(rep("0.0", nrow(ages)), collapse = ", "), ",")) %>%
  c(paste0("\t\t", paste0(rep("0.0", nrow(ages)), collapse = ", "), "],")) %>%
  c(paste0("\t\"diseases\" : [", paste0(rep("\"ncov_genpop\"", nrow(ages)), collapse = ", "), ",")) %>%
  c(paste0("\t\t", paste0(rep("\"ncov_asymp\"", nrow(ages)), collapse = ", "), ",")) %>%
  c(paste0("\t\t", paste0(rep("\"ncov_hospital\"", nrow(ages)), collapse = ", "), "]")) %>%
  c("}")
writeLines(demo, "../model_code/demographics.json")
```

<p style="color:red">NEED TO CHECK WORK / PLAY RATIOS IN DIFFERENT AGE CLASSES AND ALSO CHECK LOWER AGE GROUPS</p>

<p style="color:red">NEED TO CHECK WORK / PLAY RATIOS IN E.G. HOSPITALS</p>

<p style="color:red">to_ill_to_move for I</p>

The demographics in MetaWards is set up using the `demographics.json` file.

<button data-toggle="collapse" data-target="#demographics">Click for MetaWards <code>demographics</code> file</button>
<div id="demographics" class="collapse boxed">

```{js, code = readLines("../model_code/demographics.json"), eval = FALSE}
```

</div>

The number of stages can be set with the MetaWards disease files, called `ncov_*.json` here.

<button data-toggle="collapse" data-target="#disease">Click for MetaWards <code>disease</code> files</button>
<div id="disease" class="collapse boxed">

Here `ncov_overall.json` contains:

```{js, code = readLines("../model_code/ncov_overall.json"), eval = FALSE}
```

Here `ncov_genpop.json` contains:

```{js, code = readLines("../model_code/ncov_genpop.json"), eval = FALSE}
```

Here `ncov_asymp.json` contains:

```{js, code = readLines("../model_code/ncov_asymp.json"), eval = FALSE}
```

Here `ncov_hospital.json` contains:

```{js, code = readLines("../model_code/ncov_hospital.json"), eval = FALSE}
```

Notice that individuals in hospital have `too_ill_to_move = 1.0`, so all individuals are too ill to move.

<p style="color:red">HOW SHOULD WE SCALE `too_ill_to_move` FOR SYMPTOMATICS?</p>

We will discuss these choices in more detail in the subsequent sections. Note that the `progress` parameters are all set to zero here, since all movements will be controlled via the custom `mover` function, and all `beta` parameters are set to one for infectious classes since the scaling of the force-of-infection between the demographics will be controlled by a custom `mixer` function.

</div>

## User inputs {#user}

Various functions require additional user inputs. These are stored in the `inputs/user_inputs.txt` file. This contains information on the dates of lockdown and other parameters that are necessary to govern various custom functions as described in more detail in various sections of this vignette. For example, the input `.nage` controls the number of age-classes in the model as described above.

```{r, warning = FALSE, message = FALSE, echo = FALSE}
user <- "# Normal status" %>%
  c(".can_work[0]  = True") %>%
  c("") %>%
  c("# Lockdown 1") %>%
  c(".can_work[1]  = False") %>%
  c("") %>%
  c("# Lockdown 2") %>%
  c(".can_work[2]  = True") %>%
  c("") %>%
  c("# Lockdown dates") %>%
  c(".lockdown_date_1_year = 2020") %>%
  c(".lockdown_date_1_month = 3") %>%
  c(".lockdown_date_1_day = 21") %>%
  c(".lockdown_date_2_year = 2020") %>%
  c(".lockdown_date_2_month = 5") %>%
  c(".lockdown_date_2_day = 13") %>%
  c("") %>%
  c("# contact matrix") %>%
  c(".contact_matrix_filename = \"inputs/contact_matrix.csv\"") %>%
  c("") %>%
  c("# number of age classes") %>%
  c(paste0(".nage = ", nrow(ages))) %>%
  c("") %>%
  c("# names of input files for seeding") %>%
  c(".nseeds = 5") %>%
  c(".ward_seed_filename = \"inputs/ward_seeds.csv\"") %>%
  c(".age_seed_filename = \"inputs/age_seeds.csv\"")
writeLines(user, "../inputs/user_inputs.txt")
```

<button data-toggle="collapse" data-target="#usercode">Click for user inputs</button>
<div id="usercode" class="collapse boxed">

```{python, code = readLines("../inputs/user_inputs.txt"), eval = FALSE}
``` 

</div>

## Seeding

We seed infections into working-age `genpop` demographics only. To do this we require a set of probabilities for each age-demographic. These are stored in a file called `inputs/age_seeds.csv`, containing the probabilities below:

```{r, echo = FALSE}
age_seed <- ages %>%
  mutate(count = ifelse(ageCat == "<5", 0, count)) %>%
  mutate(count = ifelse(ageCat == "5-17", 0, count)) %>%
  mutate(count = ifelse(ageCat == "60-69", 0, count)) %>%
  mutate(count = ifelse(ageCat == "70+", 0, count)) %>%
  mutate(prop = count / sum(count)) %>%
  mutate(class = 1:n()) %>%
  select(class, prop)
write_csv(age_seed, "../inputs/age_seeds.csv", col_names = FALSE)
```

```{js, code = readLines("../inputs/age_seeds.csv"), eval = FALSE}
```

Here the first column is the age demographic and the second is the probability of seeding into that age-demographic.

We take a multinomial sample of size 5 to decide how many individuals are seeded into each age-class, and then we split these across wards as described below.

We take the first 100 observed deaths, and generate the proportions of these deaths across the relevant NHS trusts. This generates a probability of seeding infection in each trust. We then split these probabilities across all wards in these trusts proportionately to the ward population sizes. We then sample initial seeds by taking a multinomial sample of the relevant size (according to the age-class samples above) across all relevant wards. Details and instructions can be found in `data/seedDeaths/README.md`. This creates a file `inputs/ward_seeds.csv` that contains the necessary probabilities for ward seeding. This file has the same form as the `age_seeds.csv` file described above, but the first column is the ward ID, and the second is the probabilities.

> **Note**: the user inputs file must contain the relative path names to the age and ward seed files, and also the number of seeds required---see [here](#user).

To implement this probabilistic seeding, we need a custom `iterator` function, which can be viewed below. 

<button data-toggle="collapse" data-target="#iterator">Click for custom <code>iterator</code> function</button>
<div id="iterator" class="collapse boxed">

The contents of the `iterator.py` file is below. This contains code to initiate seeds and deal with lockdown (see [here](#lockdown)).

```{python, code = readLines("../model_code/iterator.py"), eval = FALSE}
```

</div>

## Parameters {#parameters}

For generic states $X$ and $Y$ say, the progress of an individual in age-class $j$ from state $X$ to state $Y$ in a given day is governed by probability $q^j_{XY}$, where:

* $q^j_{SE}$ driven by $\beta_{kj}$ parameters ($j = 1, \dots, J$), defined by $R_0$, the mean length of the infectious period ($T_I$), and the population contact matrix, $C$, between age-classes (see [here](#trans) for details);
* $q^j_{EA} = p^j_{EA}\left(1 - e^{-\gamma_{E}}\right)$ where $\gamma_E = \frac{1}{T_E}$ with $T_E$ the mean latent period;
* We model: $\log\left(p^j_{EA}\right) = \alpha_{EA} + \eta_{EA} \mbox{age}_j$, where $\eta_{EA} > 0$ and $\alpha_{EA} < -\eta_{EA} \max\left(\mbox{age}_j\right)$ to ensure than $0 < p^j_{EA} \leq 1$. The $\mbox{age}_j$ term is the middle age in age-class $j$.
* $q^j_{EI_1} = \left(1 - p^j_{EA}\right)\left(1 - e^{-\gamma_{E}}\right)$;
* $q^j_{AR} = 1 - e^{-\gamma_I}$ where $\gamma_I = \frac{1}{T_I}$ with $T_I = T_{I_1} + T_{I_2}$ the mean infectious period (assuming $T_{I_j}$ is the mean length of stay in class $I_j$);
* $q^j_{I_1I_2} = p^j_{I_1I_2}\left(1 - e^{-\gamma_{I_1}}\right)$ where $\gamma_{I_1} = \frac{1}{T_{I_1}}$;
* $q^j_{I_1H} = p^j_{I_1H}\left(1 - e^{-\gamma_{I_1}}\right)$;
* $q^j_{I_1D} = \left(1 - p^j_{I_1H} - p^j_{I_1I_2}\right)\left(1 - e^{-\gamma_{I_1}}\right)$;
* $q^j_{I_2R} = p^j_{I_2R}\left(1 - e^{-\gamma_{I_2}}\right)$ where $\gamma_{I_1} = \frac{1}{T_{I_1}}$;
* Similarly to before, we model: $\log\left(p^j_{I_1I_2/H/R}\right) = \alpha_{I_1I_2/H/R} + \eta_{I_1I_2/H/R} \mbox{age}_j$, where $\eta_{I_1I_2/H/R} > 0$ and $\alpha_{I_1I_2/H/R} < -\eta_{I_1I_2/H/R} \max\left(\mbox{age}_j\right)$ to ensure than $0 < p^j_{I_1I_2/H/R} \leq 1$.
* $q^j_{HR} = p^j_{HR}\left(1 - e^{-\gamma_{H}}\right)$ where $\gamma_H = \frac{1}{T_H}$ with $T_H$ the mean length of hospital stay;
* $q^j_{HD} = \left(1 - p^j_{HR}\right)\left(1 - e^{-\gamma_{H}}\right)$;
* Similarly to before, we model: $\log\left(p^j_{HR}\right) = \alpha_{HR} + \eta_{HR} \mbox{age}_j$, where $\eta_{HR} > 0$ and $\alpha_{HR} < -\eta_{HR} \max\left(\mbox{age}_j\right)$ to ensure than $0 < p^j_{HR} \leq 1$. 

Lockdown can be controlled either by constraining movements over a certain distance, or by scaling the $\beta_{kj}$ parameters. We do the latter at the moment. 

<button data-toggle="collapse" data-target="#trans">Click for details on transmission terms</button>
<div id="trans" class="collapse boxed">

In a standard single population model with age-structure, the force-of-infection acting on susceptibles in age-class $j$ at a given time $t$ is:
$$
    \lambda_{j} = \sum_{k = 1}^J  \beta_{kj}\frac{I_k}{N_k},
$$
where $\beta_{kj}$ is the transmission rate from class $k$ to class $j$, $I_k$ is the number of infectives in class $k$ and $N_k$ is the total number of individuals in class $k$ at time $t$ (the $t$ subscript has been dropped for brevity).

In practice we model the transmission parameters as:
$$
  \beta_{kj} = \nu c_{kj},
$$
where $0 < \nu < 1$ is a probability of infection per contact, and $c_{kj}$ is the **population contact rate** that an individual in class$j$ has with individuals in class $k$. We use the population contact matric $C = \{c_{kj}; k = 1, \dots, J; j = 1, \dots, J\}$ from the **CoMix** survey, since we are modelling from the end of the first lockdown, where contact rates are not the same as before the pandemic (where something like the BBC Pandemic Contact Survey or POLYMOD would be more appropriate).

A challenge is that we parameterise our model in terms of $R_0$, not $\nu$, and thus we need a way to derive $\nu$ from $R_0$ for a given run.

If we ignore the latent period, and assume the model is $SIR$, then $R_0$ can be derived as the **maximum eigenvalue** of the **next-generation matrix** (NGM), thus:
\begin{align}
    R_0 &= \mbox{eig}_M\left(\frac{\nu}{\gamma_I}C\right)\\
    \Rightarrow \nu &= \frac{R_0 \gamma_I}{\mbox{eig}_M\left(C\right)},
\end{align}
where $\mbox{eig}_M\left(C\right)$ denotes the maximum eigenvalue of $C$.

<p style="color:red">NEED TO ADD LATENT PERIOD TO NGM</p>

</div>

<br>

<button data-toggle="collapse" data-target="#constraints">Click for details on constraints</button>
<div id="constraints" class="collapse boxed">

The parameters we need to bound are:

* $R_0$: (2, 4.5)---from Leon and Rob;
* $T_E$ (the mean latent period): (1, 3)---bounded through generation time distribution estimated in Challen et al. (2020);
* $\alpha_{EA}$ and $\eta_{EA}$, where $\eta_{EA} > 0$ and $\alpha_{EA} < -\eta_{EA} \max\left(\mbox{age}_j\right)$;
* $T_E + T_{I_1}$ bounded by incubation period from Rob's paper maybe?
* $T_I = T_{I_1} + T_{I_2}$;
* $\alpha_{I_1I_2}$ and $\eta_{I_1I_2}$, where $\eta_{I_1I_2} > 0$ and $\alpha_{I_1I_2} < -\eta_{I_1I_2} \max\left(\mbox{age}_j\right)$;
* $\alpha_{I_1H}$ and $\eta_{I_1H}$, where $\eta_{I_1H} > 0$ and $\alpha_{I_1H} < -\eta_{I_1H} \max\left(\mbox{age}_j\right)$;
* $\alpha_{I_1D}$ and $\eta_{I_1D}$, where $\eta_{I_1D} > 0$ and $\alpha_{I_1D} < -\eta_{I_1D} \max\left(\mbox{age}_j\right)$;
* $T_H$ the mean length of hospital stay;
* $\alpha_{HR}$ and $\eta_{HR}$, where $\eta_{HR} > 0$ and $\alpha_{HR} < -\eta_{HR} \max\left(\mbox{age}_j\right)$.

</div>

MetaWards has a specific structure in terms of how it progresses movements between the stages. To get the correct splits between the **pathways** specified above we do all non-infection movements through a custom `mover` function specified [below](#mover). Note that in the `ncov.json` file specified [above](#diseasefile), we set all `progress` parameters to be 0. Thus, all transition probabilities other than new infections are driven by user-defined parameters that are passed to the `mover` function, which we call `move_pathways.py` here.

<button data-toggle="collapse" data-target="#mover">Click for MetaWards <code>mover</code> file</button>
<div id="mover" class="collapse boxed">

The `mover` function applies movements in order, and so it is important to get the order correct. In particular we need to reverse the order of the stage movements (e.g. do movements out of the $H$ demographic *before* movements out of the $I_1$ demographic). This is to ensure that individuals that move from $I_1 \to H$ say, can't then immediately move out of $H$. The file `move_pathways.py` contains the code below.

> **Additional note**: The functions in the `mover` file operate in turn. Therefore the movement probabilities below must be altered between each function, in order to get the correct proportions moved. For example, consider that we have $n$ individuals in the $I_1$ class and we want to move a proportion $p_{I_1}p_{I_1H}$ from $I_1 \to H$, a proportion $p_{I_1}p_{I_1I_2}$ from $I_1 \to I_2$, and a proportion $p_{I_1}\left(1 - p_{I_1H} - p_{I_1I_2}\right)$ from $I \to D_I$, where $p_{I_1} = 1 - e^{-\gamma_{I_1}}$.
> 
> In this case the first `mover` function takes a random binomial sample from the $n$ individuals with probability $p_{I_1}p_{I_1H}$ as requested, resulting in $n_{I_1H}$ moves. However, the second `mover` function now operates on the $n - n_{I_1H}$ individuals, so we need to adjust the sampling probabilities to adjust for this. Hence the second `mover` function needs to sample from the $n - n_{I_1H}$ individuals with probability $\frac{p_{I_1}p_{I_1I_2}}{1 - p_{I_1}p_{I_1H}}$ in order to generate the correct proportions of moves that we would expect, resulting in $n_{I_1I_2}$ moves. Similarly, the third `mover` function now operates on the $n - n_{I_1H} - n_{I_1I_2}$ remaining individuals, and thus we would need to adjust the sampling probability to $\frac{p_{I_1}\left(1 - p_{I_1H} - p_{I_1I_2}\right)}{1 - p_{I_1}\left(p_{I_1H} + p_{I_1I_2}\right)}$. The remaining individuals remain in $I_1$.

```{python, code = readLines("../model_code/move_pathways.py"), eval = FALSE}
```

</div>

## Interaction matrices

<p style="color:red">CHECK TRANSPOSE IN INTERACTION</p>

The **interaction matrix** scales the force-of-infection (FOI) that different demographics have on other demographics. We will use this to capture the effect of each age-class on the FOI for the other age-classes (see [here](#trans)). We also have two further free parameters: $\beta^S_{A \to GP}$ and $\beta^S_{H \to GP}$ which scale the impact of aymptomatics and hospital cases on the FOI to the general population. We store this information in a file called `mix_pathways.py`. 

<button data-toggle="collapse" data-target="#mixer">Click for MetaWards <code>mixing</code> file</button>
<div id="mixer" class="collapse boxed">

Since most of the classes are already infected, it's only the rows corresponding to the general population age-classes that have to contain non-zero entries. Here the `GP_A` and `GP_H` parameters scale the impact of aymptomatics and hospital cases on the force-of-infection to the general population. All demographics other than `genpop` are already infected, so have no further force-of-infection acting on them, and thus the other parameters can be set to zero. These parameters are all $> 0$.

```{python, code = readLines("../model_code/mix_pathways.py"), eval = FALSE}
```

</div>

## Lockdown

<p style="color:red">CAN SKIP THIS FOR FIRST RUNS SINCE WE RUN UP TO BEFORE LOCKDOWN</p>
<p style="color:red">LOCKDOWN TO SCALE WORK AND PLAY - TURN MOVEMENTS OF IN HOSPITALS AND ICUS</p>
<p style="color:red">TURN LOCAL MOVEMENTS OFF</p>
<p style="color:red">GOOGLE MOBILITY?</p>

Lockdown scales the FOI terms for different time periods, which each represent a different stage of interventions. We store this information in a custom `iterator` function with the corresponding parameters in `inputs/user_inputs.txt`.

Seed [here](#seeds) for full iterator function.

## Extractor {#extractor}

We also have a custom `extractor` function, that saves the outputs as a compressed SQL database for each age-class, called `stages*.db.bz2` (where `*` varies by age-class). 

Each database for a given run contains a single table called `compact`. For efficiency we:

* only store time points where an event happens within that age-class;
* only store the *incidence* data (i.e. new cases), and not the time-series counts.

This also means that wards and/or age-classes that are not infected do not return any results. 

This trick **hugely** reduces the size of the output data, but means that we have to do some **post-processing** in order to extract quantities of interest. Since the data are stored as an SQL database, we can either query the database directly, or use some of the tools in e.g. R (see [below](#recon)) to interface with it and to reconstruct time-series counts if required. 

So, to clarify, the `stages*.db` databases each contain a table called `compact` with entries:

* `day`, `ward`
* `Einc`, `Iinc`, `Rinc`, `Dinc`
* `IAinc`, `RAinc`
* `IHinc`, `RHinc`, `DHinc`

We save this custom `extractor` function in the file `ward_extractor.py`.

<button data-toggle="collapse" data-target="#ext">Click for MetaWards <code>extractor</code> file</button>
<div id="ext" class="collapse boxed">

```{python, code = readLines("../model_code/ward_extractor.py"), eval = FALSE}
```

</div>

## Input and output code {#code}

### Inputs

To run designs, we need to generate a `disease.csv` file containing different parameters to use for different runs. For consistency, we will define three spaces:

* *input* space: this relates to the parameters ranges (defined below);
* *design* space: this will usually be in $(0, 1)$ or $(-1, 1)$ space;
* *disease* space: this relates to parameters that are fed into MetaWards.

The *input* and *design* spaces are fairly trivial to convert between, but some more work has to be done to convert between the *input* space and the *disease* space. Thus we have parameter ranges:
\begin{align}
    \mbox{$R_0$}&: (2, 4.5)\\
    \mbox{mean latent period ($T_E$)}&: (4, 6)\\
    \mbox{mean infectious period ($T_I$)}&: (2, 4)\\
    \mbox{mean hospital stay ($T_H$)}&: (4, 12)\\
    \mbox{lockdown 1 restrict}&: (0, 1)\\
    \mbox{lockdown 2 release}&: (0, 1)\\
    \alpha_{EA}&: (?, ?)~\mbox{such that}~\alpha_{EA} < -\eta_{EA} \mbox{age}_M\\
    \eta_{EA}&: (0, ?)\\
    \alpha_{IH}&: (?, ?)~\mbox{such that}~\alpha_{IH} < -\eta_{IH} \mbox{age}_M\\
    \eta_{IH}&: (0, ?)\\
    \alpha_{IR}&: (?, ?)~\mbox{such that}~\alpha_{IR} < -\eta_{IR} \mbox{age}_M\\
    \eta_{IR}&: (0, ?)\\
    \alpha_{HR}&: (?, ?)~\mbox{such that}~\alpha_{HR} < -\eta_{HR} \mbox{age}_M\\
    \eta_{HR}&: (0, ?)\\
    \beta^S_{A \to GP}&: (0, 1)\\
    \beta^S_{H \to GP}&: (0, 1).
\end{align}

In R we can set up the *input* parameter ranges as follows:

```{r}
## set up parameter ranges
parRanges <- data.frame(
    parameter = c("r_zero", "latent_time", "infectious1_time", 
                  "infectious1_time", "hospital_time",
                  "lock_1_restrict", "lock_2_release",
                  "alphaEA", "etaEA", 
                  "alphaI1H", "etaI1H", 
                  "alphaI1I2", "etaI1I2",
                  "alphaI2", "etaI2",
                  "alphaHR", "etaHR",
                  "GP_A", "GP_H"),
    lower = c(2, 4, 2, 2, 4, 0, 0, rep(c("?", 0), 5), rep(0, 2)),
    upper = c(4, 6, 4, 4, 12, 1, 1, rep(c("?", "?"), 5), rep(1, 2)),
    stringsAsFactors = FALSE
)
```

Firstly we want a function to convert between the *design* and *input* spaces. A short R function called `convertDesignToInput()` which does this is given below and can be found in the `R_tools/dataTools.R` script file. This requires a `design` data frame with columns denoting each *input* parameter in `parRanges` and rows corresponding to design points. There should be an additional column called `output` that defines a unique identifier for each design point, and a column called `repeats` that contains the number of repeats for each design point. The `convertDesignToInput()` function also requires the `parRanges` data frame (defined above). We use the `scale` argument to define whether the design is on the $(0, 1)$ (`scale = "zero_one"`) or $(-1, 1)$ (`scale = "negone_one"`) space.

> **Note**: this function converts the probabilities correctly for the `mover` defined [above](#mover).

```{r, echo = FALSE}
library(knitr)
read_chunk("../R_tools/dataTools.R")
```

<button data-toggle="collapse" data-target="#convert">Click for R <code>convertDesignToInput</code> function</button>
<div id="convert" class="collapse boxed">

```{r, convertDesignToInput}
```

</div>

Once we have done this, we need to transform from the *input* space to the *disease* space for MetaWards. A `convertInputToDisease()` R function is given below and can be found in the `R_tools/dataTools.R` script file. This requires an `input` data frame, with columns denoting each *input* parameter and rows corresponding to each input points, a number of `repeats` and a column of unique identifiers (`output`).

<button data-toggle="collapse" data-target="#convert1">Click for R <code>convertInputToDisease</code> function</button>
<div id="convert1" class="collapse boxed">

```{r, convertInputToDisease}
```

</div>

Also in `R_tools/dataTools.R` is a function `ensembleIDGen()` that creates unique IDs for each design point. So an example of a quick LHS design for five design points and five replicates is given by the `convertDesign.R` script file:

```{r, code = readLines("../convertDesign.R"), eval = FALSE}
```

This produces a file `inputs/disease.dat` that can be passed to MetaWards to run the model. The batch code below provides the command line instructions needed to the model using these inputs. If you don't run Linux, then the file should give you an idea of how to run the model on your own system.

<button data-toggle="collapse" data-target="#run">Click to show code</button>
<div id="run" class="collapse boxed">

```{bash, eval = FALSE}
mkdir -p raw_outputs

R CMD BATCH --no-restore --slave --no-save convertDesign.R 

export METAWARDSDATA=$HOME/Documents/covid/MetaWardsData

metawards -d model_code/ncov_overall.json -m 2011to2019Data\
  -D model_code/demographics.json --mixer model_code/mix_pathways\
  --mover model_code/move_pathways --input inputs/disease.dat -a ExtraSeedsLondon.dat \
  -u inputs/user_inputs.txt -o raw_outputs --force-overwrite-output \
  --iterator model_code/iterate --extractor model_code/ward_extractor --start-date 2020/01/01 \
  --theme simple --nsteps 100
```

</div>

### Outputs 

<p style="color:red">HAVEN'T TOUCHED ANYTHING BELOW UNTIL WE FINALISE EXTRACTORS</p>

As described [above](#extractor) each model run produces a series of files called `stages1.db.bz2`, `stages2.db.bz2` etc., which are compressed databases containing the outputs for each age-class. In practice, it is time-consuming to unzip and extract all of these outputs for all design points, and extract and collate the various quantities we need for our emulation and history matching process. To this end we have been kindly offered a processing and data storage solution on [JASMIN](https://www.jasmin.ac.uk/). 

The simulation outputs from our model are stored at the public repository:

[https://gws-access.jasmin.ac.uk/public/covid19/](https://gws-access.jasmin.ac.uk/public/covid19/)

These are stored in the format:

```
wave
+-- inputs
+-- raw_outputs
| +-- EnsID
| | +-- stages.db
| | +-- weeksums.csv
| | +-- Cprev.csv
| | +-- Hprev.csv
| | +-- Deaths.csv
| +-- EnsIDx002
| | +-- stages.db
| | +-- weeksums.csv
| +-- EnsIDx003
| | +-- stages.db
| | +-- weeksums.csv
| +-- ...
```

The `stages*.db` files are the unzipped raw outputs for that design point (described above). The `weeksums.csv` files are weekly summaries of mean hospital prevalence (`Hprev` column), mean critical care prevalence (`Cprev` column) and total hospital + critical care deaths (`Deaths` column) on a weekly basis for each ward and week since lockdown. 

For a given ensemble ID (`Ens0000` say), the folder `Ens0000` corresponds to the first replicate for that design point. Other replicates are appended with the replicate number e.g. `Ens0000x002`, `Ens0000x003` and so on. The **main folder only** (e.g. `Ens0000`) for each design point also contains three more `.csv` files: `Hprev.csv`, `Cprev.csv` and `Deaths.csv`. These contain 0.025, 0.25, 0.5, 0.75 and 0.975 quantiles of the `Hprev`, `Cprev` and `Deaths` counts respectively taken across the replicates, and are designed to be used to build our emulators.

The main repo contains scripts to produce these in parallel on JASMIN, greatly speeding up the post-processing time. However, JASMIN is not open for general use, so these are not useful outside of the current working group. However, the results of this post-processing are detailed above and can be downloaded from the given link. A script file `downloadQuantiles.R` gives some R code that can be used to download the quantile data from a set of design IDs onto any end-user machine:

```{r, code = readLines("../downloadQuantiles.R"), eval = FALSE}
```

#### More detail on manipulating model outputs {#recon}

If you've run the model yourselves, or want to use the data differently, then as an example of how to manipulate the raw outputs, migrate to an output folder containing `stages.db.bz2` (or download one from the repo above). If this is a zipped file, then you will have to unzip it. In Linux this can be done on the command line e.g.

```{bash}
bzip2 -dkf stages1.db.bz2
```

You will notice that the unzipped `stages1.db` file is larger than the compressed version. As such, you might need to remove `stages1.db` at the end if you have limited hard drive space (to this end, the `bzip -dkf` flag I used above ensures that the original compressed file is not deleted when uncompressed). 

The database contains a single table called `compact`. To store the outputs efficiently, we have introduced various tricks, described [above](#extractor). To clarify, each `stages*.db` database contains a table called `compact` with entries:

* `day`, `ward`
* `Einc`, `Iinc`, `Rinc`, `Dinc`
* `IAinc`, `RAinc`
* `IHinc`, `RHinc`, `DHinc`
* `ICinc`, `RCinc`, `DCinc`

If you're happy with SQL, you can query these directly with e.g. SQLite. If you are an R user, then the `dplyr` package (or more specifically the `dbplyr` package) provides some useful R tools for querying SQL databases using `tidyverse`-type notation. More details about these tools can be found [here](https://cran.r-project.org/web/packages/dbplyr/vignettes/dbplyr.html).

If required, the script `R_tools/dataTools.R`, that provides a function called `reconstruct()` that is written using `Rcpp` and can be used to reconstruct the time-series counts from the incidence data.

<button data-toggle="collapse" data-target="#reconrcpp">Click for R <code>reconstruct</code> function</button>
<div id="reconrcpp" class="collapse boxed">

```{r, reconstruct}
```

</div>

As a quick example, imagine that we want to extract the **cumulative hospital cases** on say day 100 from R for the lowest age-class. (**Note that we do not need the time-series counts for this, only the incidence data.**) Here we will need to extract the **new hospital cases** from day 1--100, and then sum them up for each ward. Therefore we need to extract `day`, `ward` and `IHinc` from the `compact` table.

```{r, message = FALSE, warning = FALSE}
## load library
## (you might also need to install the 'RSQLite' 
## and `dbplyr` packages which 'dplyr' calls)
library(dplyr)

## establish connection to database
con <- DBI::dbConnect(RSQLite::SQLite(), "stages1.db")

## connect to the 'compact' table
compact <- tbl(con, "compact")

## examine
compact
```

By default, the package only pulls enough data from the database to produce a summary on the screen (notice that it prints the dimensions as `?? x 19`). If the database is small enough, then the `collect()` function can be used to import tables directly into R as a `tibble`. Alternatively, the `dbplyr` package can convert `tidyverse`-style commands into SQL and run these directly within the database. For large databases this is likely to be much more efficient, in terms of speed and memory usage. You can then `collect()` the results of the query into R.

As an example of this latter approach, we will set up a query that sums the **new** hospital cases over the first 100 days in each ward. **Remember**: for each ward the database only contains days when some event happens. For cumulative *incidence* counts this is fine, since the missing data will be zero in each case, so we just need to filter first to remove all time points $> 100$. To set up the query:

```{r}
## IHinc contains the new cases, so sum these
## over each ward for days 1--100
hosp_db <- filter(compact, day <= 100) %>%
    select(ward, IHinc) %>%
    group_by(ward) %>%
    summarise(IHcum = sum(IHinc))
```

This hasn't run any commands yet, rather `hosp_db` contains a parsed SQL query that can be run through the database connection. If you like, you can view the generated SQL query using:

```{r}
## view query
show_query(hosp_db)
```

Now let's run the query and return the results to R by passing `hosp_db` to the  `collect()` function:

```{r}
## run query and pull to R
hosp <- collect(hosp_db)

## disconnect from database
DBI::dbDisconnect(con)

## print to screen
hosp
```

Now you can play with `hosp` as much as you like. **Note** that `hosp` here only contains information about wards that have some infections, and only from the time since initial infection. Hence for calibration you might need to expand to fill in the missing wards. Fortunately, R (especially `tidyverse`) has lots of tools for doing this. 

You can very easily wrap these ideas into an R function that can scroll through the design IDs, extract relevant outputs and bind to the inputs. Note that this data processing takes a lot of time, so running in parallel is very helpful. Hence why we do all this on JASMIN.

```{r, echo = FALSE, message = FALSE, warning = FALSE, eval = FALSE}
## copy data across
system("cp ../data/contactData/contact_matrix.csv ../inputs/")
system("cp ../data/populationByAge/Pop\\ by\\ CTRY.csv ../inputs/")
tempdir <- getwd()
setwd("..")
source("convertDesign.R")
system("zip metawards.zip model_code/* R_tools/* vignette/* convertDesign.R downloadQuantiles.R runscript.sh README.sh")
setwd(tempdir)
```

